package cs13b027_lab8_1;

import java.util.LinkedList;
import java.util.Scanner;

public class FordFulkerson {

	private static int n, m, destIdx;

	public static void main(String[] args) {

		Scanner input = new Scanner(System.in);
		n = input.nextInt();
		m = input.nextInt();
		Graph graph = new Graph(n, m);
		Graph residualGraph = new Graph(n, m);
		int nodeIdx1, nodeIdx2, capacity;
		destIdx = n - 1;
		boolean stat;
		for (int i = 0; i < m; i++) {
			stat = false;
			nodeIdx1 = input.nextInt();
			nodeIdx2 = input.nextInt();
			capacity = input.nextInt();
			for (Edge edge : graph.getAdjacentEdges(nodeIdx2)) {
				if (edge.getSecondNode().getIndex() == nodeIdx1) {
					
					Node node = new Node(graph.getAdjacencyList().size());
					graph.getAllNodes().add(node);
					node = new Node(residualGraph.getAdjacencyList().size());
					residualGraph.getAllNodes().add(node);
					
					graph.getAdjacencyList().add(new LinkedList<Edge>());
					residualGraph.getAdjacencyList()
							.add(new LinkedList<Edge>());
					n++;
					graph.addEdge(nodeIdx1, n - 1, capacity);
					residualGraph.addUndirectedEdge(nodeIdx1, n - 1, capacity);
					graph.addEdge(n - 1, nodeIdx2, capacity);
					graph.addUndirectedEdge(n - 1, nodeIdx2, capacity);
					m += 2;
					stat = true;
					break;
				}
			}
			if (!stat) {
				graph.addEdge(nodeIdx1, nodeIdx2, capacity);
				residualGraph.addUndirectedEdge(nodeIdx1, nodeIdx2, capacity);
			}

		}
		
		int min;
		while (getPath(residualGraph, 0)) {
			min = getMin(residualGraph, 0, Integer.MAX_VALUE);
			updateFlow(graph, 0, min);
			updateResidualGraph(residualGraph, 0, min);
		}
		min = 0;
		for (Edge edge : graph.getAdjacencyList().get(destIdx)) {
			min += edge.getFlow();
		}
		
		System.out.println(min);

	}

	public static boolean getPath(Graph graph, int nodeIdx) {
		if (nodeIdx == destIdx) {
			return true;
		}

		for (Edge edge : graph.getAdjacentEdges(nodeIdx)) {
			if (edge.getFlow() > 0 && edge.getPathMark() == false) {
				edge.setPathMark(true);
				if (getPath(graph, edge.getSecondNode().getIndex())) {
					return true;
				}
				edge.setPathMark(false);
			}
		}
		return false;
	}

	public static int getMin(Graph graph, int nodeIdx, int min) {
		
		if(nodeIdx == destIdx){
			return min;
		}
		
		for (Edge edge : graph.getAdjacentEdges(nodeIdx)) {
			if (edge.getPathMark() && edge.getVisitStatus()) {
				min = edge.getFlow() < min ? edge.getFlow() : min;
				return getMin(graph, edge.getSecondNode().getIndex(), min);
			}
		}
		return min;
	}

	public static void updateFlow(Graph graph, int nodeIdx, int min) {
		if(nodeIdx == destIdx){
			return;
		}
		
		for (Edge edge : graph.getAdjacentEdges(nodeIdx)) {
			if (edge.getPathMark()) {
				edge.setFlow(edge.getFlow() + min);
				updateFlow(graph, edge.getSecondNode().getIndex(), min);
				break;
			}
		}
	}

	public static void updateResidualGraph(Graph graph, int nodeIdx, int min) {
		
		if(nodeIdx == destIdx){
			return;
		}
		
		for (Edge edge : graph.getAdjacentEdges(nodeIdx)) {
			if (edge.getPathMark()) {
				edge.setFlow(edge.getFlow() - min);
				for (Edge temp : graph.getAdjacencyList().get(
						edge.getSecondNode().getIndex())) {
					if (temp.getSecondNode().getIndex() == edge.getFirstNode()
							.getIndex()) {
						temp.setFlow(temp.getFlow() + min);
						break;
					}
				}
				edge.setPathMark(false);
				break;
			}
		}
	}

}
